# Signature Verification Module

This module provides HMAC-SHA256 signature verification capabilities for TypeScript/JavaScript applications, compatible with Go server implementations.

## Overview

The signature verification module allows you to:
- Verify HMAC-SHA256 signatures generated by your Go server
- Generate signatures for testing purposes
- Secure webhook endpoints
- Verify API responses and file integrity
- Handle real-time message verification

## Installation

```typescript
import { SignatureVerifier, SignatureUtils } from './signature';
```

## Quick Start

### Basic Usage

```typescript
// Simple verification using utility functions
const isValid = SignatureUtils.verifyJson(
  { message: "hello world" },
  "signature-from-server",
  "your-secret-key"
);

// Create a reusable verifier instance
const verifier = new SignatureVerifier("your-secret-key");
const isValid = verifier.verifyJsonSignature(jsonData, signature);
```

### Go Server Compatibility

This module is designed to work with Go servers that generate signatures like this:

```go
func generateTestSignature(payload []byte, secret string) string {
    h := hmac.New(sha256.New, []byte(secret))
    h.Write(payload)
    return hex.EncodeToString(h.Sum(nil))
}
```

## API Reference

### SignatureVerifier Class

#### Constructor
```typescript
new SignatureVerifier(secret: string)
```

#### Methods

##### `generateSignature(payload: string | Buffer): string`
Generates an HMAC-SHA256 signature for the given payload.

```typescript
const signature = verifier.generateSignature("hello world");
```

##### `verifySignature(payload: string | Buffer, signature: string): boolean`
Verifies a signature against a payload.

```typescript
const isValid = verifier.verifySignature("hello world", signature);
```

##### `verifyJsonSignature(jsonPayload: object | string, signature: string): boolean`
Verifies a signature against a JSON payload (object or string).

```typescript
const isValid = verifier.verifyJsonSignature({ key: "value" }, signature);
```

##### `verifyBytesSignature(payload: Uint8Array, signature: string): boolean`
Verifies a signature against raw bytes.

```typescript
const bytes = new Uint8Array([1, 2, 3, 4]);
const isValid = verifier.verifyBytesSignature(bytes, signature);
```

### SignatureUtils Static Methods

#### `create(secret: string): SignatureVerifier`
Creates a new SignatureVerifier instance.

#### `verifyJson(jsonPayload: object | string, signature: string, secret: string): boolean`
Quick JSON verification without creating an instance.

#### `verify(payload: string | Buffer, signature: string, secret: string): boolean`
Quick verification without creating an instance.

#### `generate(payload: string | Buffer, secret: string): string`
Quick signature generation without creating an instance.

## Common Use Cases

### 1. Webhook Verification

```typescript
import express from 'express';
import { SignatureUtils } from './signature';

const app = express();

app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-signature'] as string;
  const payload = req.body;
  const secret = process.env.WEBHOOK_SECRET!;
  
  if (!SignatureUtils.verify(payload, signature, secret)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process webhook...
  res.json({ success: true });
});
```

### 2. Express Middleware

```typescript
function webhookVerification(secret: string) {
  return (req: any, res: any, next: any) => {
    const signature = req.headers['x-signature'];
    if (!signature) {
      return res.status(401).json({ error: 'Missing signature' });
    }
    
    const isValid = SignatureUtils.verify(req.rawBody, signature, secret);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    next();
  };
}

app.use('/webhook', webhookVerification(process.env.SECRET!));
```

### 3. API Client with Verification

```typescript
class SecureApiClient {
  constructor(private secret: string) {}
  
  async post(url: string, data: object) {
    const payload = JSON.stringify(data);
    const signature = SignatureUtils.generate(payload, this.secret);
    
    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Signature': signature,
      },
      body: payload,
    });
  }
  
  async verifyResponse(response: any, expectedSignature: string): Promise<boolean> {
    return SignatureUtils.verifyJson(response, expectedSignature, this.secret);
  }
}
```

### 4. File Integrity Verification

```typescript
async function verifyUploadedFile(file: File, signature: string, secret: string): Promise<boolean> {
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  return SignatureUtils.verify(buffer, signature, secret);
}
```

### 5. Real-time Message Verification

```typescript
class SecureWebSocket {
  private verifier: SignatureVerifier;
  
  constructor(secret: string) {
    this.verifier = new SignatureVerifier(secret);
  }
  
  send(ws: WebSocket, message: object) {
    const payload = JSON.stringify(message);
    const signature = this.verifier.generateSignature(payload);
    
    ws.send(JSON.stringify({
      payload: message,
      signature,
      timestamp: Date.now(),
    }));
  }
  
  verify(messageData: string): { valid: boolean; payload?: object } {
    try {
      const { payload, signature } = JSON.parse(messageData);
      const valid = this.verifier.verifyJsonSignature(payload, signature);
      return { valid, payload: valid ? payload : undefined };
    } catch {
      return { valid: false };
    }
  }
}
```

## Security Features

### Timing-Safe Comparison
The module uses `crypto.timingSafeEqual()` to prevent timing attacks when comparing signatures.

### Error Handling
All verification methods return `false` for invalid inputs rather than throwing exceptions, making them safe to use in production.

### Input Validation
- Automatically handles different input types (string, Buffer, object)
- Gracefully handles malformed hex signatures
- Validates JSON serialization

## Testing

The module includes comprehensive tests demonstrating:
- Basic signature generation and verification
- JSON object handling
- Buffer and binary data support
- Go server compatibility
- Error handling scenarios
- Timing attack resistance

Run tests with:
```bash
npm test
```

## Environment Variables

When using in production, store your secret keys securely:

```typescript
const secret = process.env.SIGNATURE_SECRET;
if (!secret) {
  throw new Error('SIGNATURE_SECRET environment variable is required');
}
```

## Best Practices

1. **Use environment variables** for secret keys, never hardcode them
2. **Validate signatures** before processing any external data
3. **Use raw body data** for webhook verification, not parsed JSON
4. **Handle errors gracefully** - verification failures should not crash your application
5. **Log security events** for monitoring and debugging
6. **Rotate secrets** periodically for enhanced security
7. **Use HTTPS** in production to protect signatures in transit

## Troubleshooting

### Common Issues

**Signature verification always fails:**
- Ensure the secret key matches between client and server
- Verify you're using the raw payload data, not parsed JSON
- Check that the signature is properly hex-encoded

**Different signatures for same data:**
- JSON object key order matters - use the same serialization method
- Ensure consistent encoding (UTF-8)
- Verify no extra whitespace or formatting differences

**Performance concerns:**
- Create a single `SignatureVerifier` instance and reuse it
- Use `SignatureUtils` for one-off verifications
- Consider caching for frequently verified payloads

### Debug Mode

Enable debug logging to troubleshoot signature mismatches:

```typescript
const verifier = new SignatureVerifier(secret);
const expectedSignature = verifier.generateSignature(payload);
console.log('Expected:', expectedSignature);
console.log('Received:', receivedSignature);
console.log('Match:', expectedSignature === receivedSignature);
```

## License

This module is part of the TypeScript SDK and follows the same licensing terms.